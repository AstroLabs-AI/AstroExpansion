package com.astrolabs.astroexpansion.client.renderer;

import com.mojang.blaze3d.vertex.PoseStack;
import com.mojang.blaze3d.vertex.VertexConsumer;
import net.minecraft.client.model.EntityModel;
import net.minecraft.client.model.geom.ModelLayerLocation;
import net.minecraft.client.model.geom.ModelPart;
import net.minecraft.client.model.geom.PartPose;
import net.minecraft.client.model.geom.builders.*;
import net.minecraft.client.renderer.MultiBufferSource;
import net.minecraft.client.renderer.RenderType;
import net.minecraft.client.renderer.entity.EntityRenderer;
import net.minecraft.client.renderer.entity.EntityRendererProvider;
import net.minecraft.client.renderer.texture.OverlayTexture;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.world.entity.Entity;

import java.util.Map;
import java.util.HashMap;

public class RocketRenderer<T extends Entity> extends EntityRenderer<T> {
    public static final ModelLayerLocation ROCKET_LAYER = new ModelLayerLocation(
            new ResourceLocation("astroexpansion", "rocket"), "main");
    
    // Debug flag - turn on to see debug info in console
    private static final boolean DEBUG_RENDERING = true;
    
    private final ResourceLocation texture;
    private final RocketModel<T> model;
    
    private final String rocketType;
    
    // We'll store multiple textures for different rocket parts
    private final Map<String, ResourceLocation> partTextures = new HashMap<>();
    
    public RocketRenderer(EntityRendererProvider.Context context, String type) {
        super(context);
        this.rocketType = type;
        
        // Use custom rocket textures generated by the texture generator
        if (type.equals("probe")) {
            // Main probe rocket texture for the whole model
            this.texture = new ResourceLocation("astroexpansion", "textures/entity/probe_rocket.png");
            
            // Individual part textures (using the same main texture for most parts for now)
            partTextures.put("body", new ResourceLocation("astroexpansion", "textures/entity/probe_rocket.png"));
            partTextures.put("nose", new ResourceLocation("astroexpansion", "textures/entity/probe_rocket.png"));
            partTextures.put("fins", new ResourceLocation("astroexpansion", "textures/entity/probe_rocket.png"));
            partTextures.put("nozzle", new ResourceLocation("astroexpansion", "textures/entity/probe_rocket.png"));
            partTextures.put("antenna", new ResourceLocation("astroexpansion", "textures/entity/probe_rocket.png"));
            partTextures.put("details", new ResourceLocation("astroexpansion", "textures/entity/probe_rocket.png"));
            partTextures.put("windows", new ResourceLocation("astroexpansion", "textures/entity/probe_rocket.png"));
            partTextures.put("flame", new ResourceLocation("astroexpansion", "textures/entity/probe_rocket.png"));
            partTextures.put("base", new ResourceLocation("astroexpansion", "textures/entity/probe_rocket.png"));
            partTextures.put("strut1", new ResourceLocation("astroexpansion", "textures/entity/probe_rocket.png"));
            partTextures.put("strut2", new ResourceLocation("astroexpansion", "textures/entity/probe_rocket.png"));
            partTextures.put("payload", new ResourceLocation("astroexpansion", "textures/entity/probe_rocket.png"));
        } else if (type.equals("personal")) {
            // Personal rocket texture
            this.texture = new ResourceLocation("astroexpansion", "textures/entity/personal_rocket.png");
            
            // Individual part textures
            partTextures.put("body", new ResourceLocation("astroexpansion", "textures/entity/personal_rocket.png"));
            partTextures.put("nose", new ResourceLocation("astroexpansion", "textures/entity/personal_rocket.png"));
            partTextures.put("fins", new ResourceLocation("astroexpansion", "textures/entity/personal_rocket.png"));
            partTextures.put("nozzle", new ResourceLocation("astroexpansion", "textures/entity/personal_rocket.png"));
            partTextures.put("antenna", new ResourceLocation("astroexpansion", "textures/entity/personal_rocket.png"));
            partTextures.put("details", new ResourceLocation("astroexpansion", "textures/entity/personal_rocket.png"));
            partTextures.put("windows", new ResourceLocation("astroexpansion", "textures/entity/personal_rocket.png"));
            partTextures.put("flame", new ResourceLocation("astroexpansion", "textures/entity/personal_rocket.png"));
        } else if (type.equals("cargo")) {
            // Cargo rocket texture
            this.texture = new ResourceLocation("astroexpansion", "textures/entity/cargo_shuttle.png");
            
            // Individual part textures
            partTextures.put("body", new ResourceLocation("astroexpansion", "textures/entity/cargo_shuttle.png"));
            partTextures.put("nose", new ResourceLocation("astroexpansion", "textures/entity/cargo_shuttle.png"));
            partTextures.put("fins", new ResourceLocation("astroexpansion", "textures/entity/cargo_shuttle.png"));
            partTextures.put("nozzle", new ResourceLocation("astroexpansion", "textures/entity/cargo_shuttle.png"));
            partTextures.put("details", new ResourceLocation("astroexpansion", "textures/entity/cargo_shuttle.png"));
            partTextures.put("windows", new ResourceLocation("astroexpansion", "textures/entity/cargo_shuttle.png"));
            partTextures.put("flame", new ResourceLocation("astroexpansion", "textures/entity/rocket_cargo.png"));
        } else {
            // Research/mining rocket (default) - using cargo rocket texture as fallback
            // since research texture doesn't exist yet
            this.texture = new ResourceLocation("astroexpansion", "textures/entity/cargo_shuttle.png");
            
            // Individual part textures
            partTextures.put("body", new ResourceLocation("astroexpansion", "textures/entity/cargo_shuttle.png"));
            partTextures.put("nose", new ResourceLocation("astroexpansion", "textures/entity/cargo_shuttle.png"));
            partTextures.put("fins", new ResourceLocation("astroexpansion", "textures/entity/cargo_shuttle.png"));
            partTextures.put("boosters", new ResourceLocation("astroexpansion", "textures/entity/rocket_cargo.png"));
            partTextures.put("nozzle", new ResourceLocation("astroexpansion", "textures/entity/cargo_shuttle.png"));
            partTextures.put("details", new ResourceLocation("astroexpansion", "textures/entity/cargo_shuttle.png"));
            partTextures.put("windows", new ResourceLocation("astroexpansion", "textures/entity/cargo_shuttle.png"));
            partTextures.put("flame", new ResourceLocation("astroexpansion", "textures/entity/rocket_cargo.png"));
        }
        
        if (DEBUG_RENDERING) {
            System.out.println("Using custom textures for rocket type: " + type);
        }
        
        this.model = new RocketModel<>(context.bakeLayer(ROCKET_LAYER), type);
        this.shadowRadius = 0.8F;
        this.shadowStrength = 0.9F;
    }
    
    @Override
    public void render(@javax.annotation.Nonnull T entity, float entityYaw, float partialTicks, @javax.annotation.Nonnull PoseStack poseStack, 
                      @javax.annotation.Nonnull MultiBufferSource buffer, int packedLight) {
        poseStack.pushPose();
        
        // Fix rocket orientation - rockets were rendering upside down
        // Rotate 180 degrees around X axis to flip the model right-side up
        poseStack.mulPose(com.mojang.math.Axis.XP.rotationDegrees(180));
        // Adjust Y position based on rocket type
        if (this.rocketType.equals("probe")) {
            poseStack.translate(0.0D, -3.0F, 0.0D);  // Adjusted to display probe rocket at proper height
        } else if (this.rocketType.equals("personal")) {
            poseStack.translate(0.0D, -2.0F, 0.0D); // Personal rocket needs medium adjustment
        } else if (this.rocketType.equals("cargo")) {
            poseStack.translate(0.0D, -5.0F, 0.0D); // Cargo shuttle is larger and needs more adjustment
        } else {
            poseStack.translate(0, -2.0, 0); // Default adjustment for other types
        }
        
        // Translate slightly forward to center the model on the launch rail/pad
        poseStack.translate(0, 0, -0.2);
        
        // Adjust scaling based on rocket type - 2x bigger as requested
        if (rocketType.equals("probe")) {
            // Small satellite probe (leftmost in reference) - 2x bigger
            poseStack.scale(1.2F, 1.4F, 1.2F); // 2x bigger than before
        } else if (rocketType.equals("personal")) {
            // Personal rocket sized to fit a player (1 block width minimum) - 2x bigger
            poseStack.scale(1.6F, 2.0F, 1.6F); // 2x bigger than before
        } else if (rocketType.equals("cargo")) {
            // Saturn V style (third from left in reference) - 2x bigger
            poseStack.scale(2.0F, 2.4F, 2.0F); // 2x bigger than before
        } else {
            // Space shuttle style (rightmost in reference) - 2x bigger
            poseStack.scale(2.4F, 1.8F, 1.4F); // 2x bigger than before
        }
        
        // Position rocket to sit properly on the launch rail
        poseStack.translate(0.0, 0.5, 0.0); // Raise it slightly to show the base better
        
        // No rotation needed - removing the previous 180 degree rotation
        // that was causing the rocket to appear upside down
        
        // Add a slight rotation for better visibility
        poseStack.mulPose(com.mojang.math.Axis.YP.rotationDegrees(45.0F)); // Turn the rocket 45 degrees for better visibility
        
        // Very subtle wobble to add life to the model
        float wobble = (float)Math.sin(entity.tickCount * 0.03F) * 0.02F;
        poseStack.mulPose(com.mojang.math.Axis.YP.rotationDegrees(wobble));
        
        if (DEBUG_RENDERING) {
            System.out.println("Rendering rocket at position: " + entity.getX() + ", " + entity.getY() + ", " + entity.getZ());
            System.out.println("Rocket type: " + rocketType);
        }
        
        // Render the model with different textures for each part
        // Main body
        VertexConsumer bodyConsumer = buffer.getBuffer(RenderType.entityCutout(
            partTextures.getOrDefault("body", texture)));
        this.model.renderBody(poseStack, bodyConsumer, packedLight, OverlayTexture.NO_OVERLAY, 
                           1.0F, 1.0F, 1.0F, 1.0F);
        
        // Nose cone
        VertexConsumer noseConsumer = buffer.getBuffer(RenderType.entityCutout(
            partTextures.getOrDefault("nose", texture)));
        this.model.renderNose(poseStack, noseConsumer, packedLight, OverlayTexture.NO_OVERLAY, 
                           1.0F, 1.0F, 1.0F, 1.0F);
        
        // Fins 
        VertexConsumer finsConsumer = buffer.getBuffer(RenderType.entityCutout(
            partTextures.getOrDefault("fins", texture)));
        this.model.renderFins(poseStack, finsConsumer, packedLight, OverlayTexture.NO_OVERLAY, 
                           1.0F, 1.0F, 1.0F, 1.0F);
        
        // Nozzle
        VertexConsumer nozzleConsumer = buffer.getBuffer(RenderType.entityCutout(
            partTextures.getOrDefault("nozzle", texture)));
        this.model.renderNozzle(poseStack, nozzleConsumer, packedLight, OverlayTexture.NO_OVERLAY, 
                             1.0F, 1.0F, 1.0F, 1.0F);
        
        // Add particle effects on the client side
        if (entity.level().isClientSide) {
            // Check if this is a launched rocket
            if (entity instanceof com.astrolabs.astroexpansion.common.entity.PersonalRocketEntity ||
                entity instanceof com.astrolabs.astroexpansion.common.entity.ProbeRocketEntity) {
                // Add pre-launch effects
                addRocketEffects(entity, partialTicks);
            }
        }
        
        poseStack.popPose();
        super.render(entity, entityYaw, partialTicks, poseStack, buffer, packedLight);
    }
    
    private void addRocketEffects(T entity, float partialTicks) {
        java.util.Random rand = new java.util.Random();
        double x = entity.getX();
        double y = entity.getY() - 1.0; // Lower particle position to match rocket base
        double z = entity.getZ();
        
        // Check if the rocket is moving upward (launched)
        boolean isLaunched = entity.getDeltaMovement().y > 0.1;
        
        // Enhanced rocket effects based on rocket type to match reference image
        if (isLaunched) {
            // Customize flame effects based on rocket type
            if (rocketType.equals("probe")) {
                // Probe/satellite - smaller blue flame with less smoke
                addProbeFlameEffects(entity, x, y, z, rand);
            } else if (rocketType.equals("personal")) {
                // V2-style rocket - focused orange flame
                addPersonalRocketFlameEffects(entity, x, y, z, rand);
            } else if (rocketType.equals("cargo")) {
                // Saturn V style - multiple large orange/yellow flames
                addCargoRocketFlameEffects(entity, x, y, z, rand);
            } else {
                // Space Shuttle style - wide flame pattern with intense heat
                addShuttleFlameEffects(entity, x, y, z, rand);
            }
        } else {
            // Pre-launch effects - vary by rocket type
            if (entity.tickCount % 10 == 0) { // Occasional pre-launch effects
                if (rocketType.equals("probe") || rocketType.equals("personal")) {
                    // Smaller rockets have minimal pre-launch effects
                    entity.level().addParticle(
                        net.minecraft.core.particles.ParticleTypes.SMOKE,
                        x, y, z,
                        0, 0.01, 0);
                } else {
                    // Larger rockets have more visible pre-launch preparations
                    double offsetX = (rand.nextDouble() - 0.5) * 0.3;
                    double offsetZ = (rand.nextDouble() - 0.5) * 0.3;
                    
                    entity.level().addParticle(
                        net.minecraft.core.particles.ParticleTypes.CLOUD,
                        x + offsetX, y, z + offsetZ,
                        0, 0.02, 0);
                        
                    if (entity.tickCount % 30 == 0) {
                        // Occasional steam/venting effect
                        entity.level().addParticle(
                            net.minecraft.core.particles.ParticleTypes.POOF,
                            x, y, z,
                            (rand.nextDouble() - 0.5) * 0.1, 0.05, (rand.nextDouble() - 0.5) * 0.1);
                    }
                }
            }
        }
    }
    
    // Flame effects for probe/satellite (small blue/cyan flame)
    private void addProbeFlameEffects(T entity, double x, double y, double z, java.util.Random rand) {
        if (entity.tickCount % 2 == 0) {
            // Small focused flame for the probe - blue tint
            double offsetX = (rand.nextDouble() - 0.5) * 0.1;
            double offsetZ = (rand.nextDouble() - 0.5) * 0.1;
            
            // Small blue flame
            entity.level().addParticle(
                net.minecraft.core.particles.ParticleTypes.SOUL_FIRE_FLAME,
                x + offsetX, y - 0.3, z + offsetZ,
                0, -0.1, 0);
                
            if (entity.tickCount % 6 == 0) {
                // Minimal smoke
                entity.level().addParticle(
                    net.minecraft.core.particles.ParticleTypes.SMOKE,
                    x, y - 0.4, z,
                    0, -0.05, 0);
            }
        }
    }
    
    // Flame effects for personal/V2 rocket (focused orange flame)
    private void addPersonalRocketFlameEffects(T entity, double x, double y, double z, java.util.Random rand) {
        if (entity.tickCount % 2 == 0) {
            // Focused center flame
            entity.level().addParticle(
                net.minecraft.core.particles.ParticleTypes.FLAME,
                x, y - 0.5, z,
                0, -0.15, 0);
                
            // Side flames
            double offsetX = (rand.nextDouble() - 0.5) * 0.2;
            double offsetZ = (rand.nextDouble() - 0.5) * 0.2;
            
            entity.level().addParticle(
                net.minecraft.core.particles.ParticleTypes.FLAME,
                x + offsetX, y - 0.4, z + offsetZ,
                offsetX * 0.1, -0.1, offsetZ * 0.1);
                
            // Smoke trail
            if (entity.tickCount % 3 == 0) {
                entity.level().addParticle(
                    net.minecraft.core.particles.ParticleTypes.LARGE_SMOKE,
                    x + offsetX * 1.5, y - 0.6, z + offsetZ * 1.5,
                    0, -0.05, 0);
            }
        }
    }
    
    // Flame effects for cargo/Saturn V rocket (multiple large orange/yellow flames)
    private void addCargoRocketFlameEffects(T entity, double x, double y, double z, java.util.Random rand) {
        // Multiple engine nozzles with larger flame patterns
        for (int i = 0; i < 4; i++) {
            double offsetX = (i == 0 || i == 2) ? 0.3 : -0.3;
            double offsetZ = (i < 2) ? 0.3 : -0.3;
            
            // Orange-yellow flames with variation
            entity.level().addParticle(
                net.minecraft.core.particles.ParticleTypes.FLAME,
                x + offsetX * rand.nextDouble(), y - 0.5, z + offsetZ * rand.nextDouble(),
                offsetX * 0.05, -0.2 - rand.nextDouble() * 0.1, offsetZ * 0.05);
                
            // Lava particles for more intense flame effect
            if (entity.tickCount % 3 == 0) {
                entity.level().addParticle(
                    net.minecraft.core.particles.ParticleTypes.LAVA,
                    x + offsetX * 0.7, y - 0.4, z + offsetZ * 0.7,
                    0, 0, 0);
            }
            
            // Dense smoke cloud
            if (entity.tickCount % 2 == 0) {
                entity.level().addParticle(
                    net.minecraft.core.particles.ParticleTypes.LARGE_SMOKE,
                    x + offsetX, y - 0.7 - rand.nextDouble() * 0.3, z + offsetZ,
                    offsetX * 0.02, -0.05, offsetZ * 0.02);
            }
        }
    }
    
    // Flame effects for shuttle (wide flame pattern with intense heat)
    private void addShuttleFlameEffects(T entity, double x, double y, double z, java.util.Random rand) {
        // Main engines - three in triangular pattern
        for (int i = 0; i < 3; i++) {
            double offsetX = 0;
            double offsetZ = 0;
            
            if (i == 0) {
                // Center engine
                offsetX = 0;
                offsetZ = 0;
            } else if (i == 1) {
                // Right engine
                offsetX = 0.25;
                offsetZ = 0;
            } else {
                // Left engine
                offsetX = -0.25;
                offsetZ = 0;
            }
            
            // Intense flame with variation
            entity.level().addParticle(
                net.minecraft.core.particles.ParticleTypes.FLAME,
                x + offsetX, y - 0.5, z + offsetZ,
                offsetX * 0.05, -0.2 - rand.nextDouble() * 0.1, offsetZ * 0.05);
                
            // Additional smaller flames
            double microOffsetX = (rand.nextDouble() - 0.5) * 0.15;
            double microOffsetZ = (rand.nextDouble() - 0.5) * 0.15;
            
            entity.level().addParticle(
                net.minecraft.core.particles.ParticleTypes.FLAME,
                x + offsetX + microOffsetX, y - 0.6, z + offsetZ + microOffsetZ,
                microOffsetX * 0.1, -0.15, microOffsetZ * 0.1);
        }
        
        // Solid rocket boosters - larger flame with different pattern
        if (entity.tickCount % 2 == 0) {
            // Left booster
            double offsetX = -1.0;
            entity.level().addParticle(
                net.minecraft.core.particles.ParticleTypes.LAVA,
                x + offsetX, y - 0.3, z,
                0, 0, 0);
                
            entity.level().addParticle(
                net.minecraft.core.particles.ParticleTypes.FLAME,
                x + offsetX, y - 0.5, z,
                offsetX * 0.02, -0.2, 0);
                
            // Right booster
            offsetX = 1.0;
            entity.level().addParticle(
                net.minecraft.core.particles.ParticleTypes.LAVA,
                x + offsetX, y - 0.3, z,
                0, 0, 0);
                
            entity.level().addParticle(
                net.minecraft.core.particles.ParticleTypes.FLAME,
                x + offsetX, y - 0.5, z,
                offsetX * 0.02, -0.2, 0);
        }
        
        // Dense smoke cloud below
        if (entity.tickCount % 3 == 0) {
            double smokeOffsetX = (rand.nextDouble() - 0.5) * 1.5;
            double smokeOffsetZ = (rand.nextDouble() - 0.5) * 0.5;
            
            entity.level().addParticle(
                net.minecraft.core.particles.ParticleTypes.LARGE_SMOKE,
                x + smokeOffsetX, y - 0.8, z + smokeOffsetZ,
                smokeOffsetX * 0.01, -0.05, smokeOffsetZ * 0.01);
        }
    }
    
    @Override
    public ResourceLocation getTextureLocation(@javax.annotation.Nonnull T entity) {
        return texture;
    }
    
    public static LayerDefinition createBodyLayer() {
        MeshDefinition meshDefinition = new MeshDefinition();
        PartDefinition partDefinition = meshDefinition.getRoot();

        // Create a more realistic, wider rocket body - much better proportions
        partDefinition.addOrReplaceChild("body", 
            CubeListBuilder.create()
                .texOffs(0, 0)
                .addBox(-4.0F, -16.0F, -4.0F, 8.0F, 22.0F, 8.0F), // Much wider, more realistic body (8x22x8)
            PartPose.offset(0.0F, 8.0F, 0.0F));

        // Add a much more prominent, realistic nose cone with proper tapering
        partDefinition.addOrReplaceChild("nose", 
            CubeListBuilder.create()
                .texOffs(32, 0)
                // Create a multi-stage tapered nose cone for realistic appearance
                .addBox(-2.0F, -28.0F, -2.0F, 4.0F, 3.0F, 4.0F)    // Tip section (narrowest)
                .texOffs(32, 7)
                .addBox(-3.0F, -25.0F, -3.0F, 6.0F, 4.0F, 6.0F)   // Middle section
                .texOffs(32, 17)
                .addBox(-4.0F, -21.0F, -4.0F, 8.0F, 5.0F, 8.0F),  // Base section (matches body width)
            PartPose.offset(0.0F, 8.0F, 0.0F));

        // Create larger, more prominent stabilizing fins with proper alignment
        // Front fin - properly aligned
        partDefinition.addOrReplaceChild("fin1", 
            CubeListBuilder.create()
                .texOffs(0, 30)
                // Create a properly aligned triangular fin shape
                .addBox(-1.5F, -2.0F, -8.0F, 3.0F, 4.0F, 6.0F)    // Base of fin (larger, properly centered)
                .texOffs(0, 40)
                .addBox(-1.0F, 2.0F, -9.0F, 2.0F, 3.0F, 5.0F)   // Middle of fin (inverted to point down)
                .texOffs(0, 48)
                .addBox(-0.5F, 5.0F, -10.0F, 1.0F, 3.0F, 3.0F), // Tip of fin (inverted to point down)
            PartPose.offset(0.0F, 8.0F, 0.0F));

        // Back fin - properly aligned (opposite direction)
        partDefinition.addOrReplaceChild("fin2", 
            CubeListBuilder.create()
                .texOffs(18, 30)
                .addBox(-1.5F, -2.0F, 2.0F, 3.0F, 4.0F, 6.0F)     // Base of fin (properly centered)
                .texOffs(18, 40)
                .addBox(-1.0F, 2.0F, 4.0F, 2.0F, 3.0F, 5.0F)    // Middle of fin (inverted to point down)
                .texOffs(18, 48)
                .addBox(-0.5F, 5.0F, 7.0F, 1.0F, 3.0F, 3.0F),   // Tip of fin (inverted to point down)
            PartPose.offset(0.0F, 8.0F, 0.0F));

        // Left fin - properly aligned
        partDefinition.addOrReplaceChild("fin3", 
            CubeListBuilder.create()
                .texOffs(36, 30)
                .addBox(-8.0F, -2.0F, -1.5F, 6.0F, 4.0F, 3.0F)    // Base of fin (properly centered)
                .texOffs(36, 40)
                .addBox(-9.0F, 2.0F, -1.0F, 5.0F, 3.0F, 2.0F)   // Middle of fin (inverted to point down)
                .texOffs(36, 48)
                .addBox(-10.0F, 5.0F, -0.5F, 3.0F, 3.0F, 1.0F), // Tip of fin (inverted to point down)
            PartPose.offset(0.0F, 8.0F, 0.0F));

        // Right fin - properly aligned (mirror of left)
        partDefinition.addOrReplaceChild("fin4", 
            CubeListBuilder.create()
                .texOffs(54, 30)
                .addBox(2.0F, -2.0F, -1.5F, 6.0F, 4.0F, 3.0F)     // Base of fin (properly centered)
                .texOffs(54, 40)
                .addBox(4.0F, 2.0F, -1.0F, 5.0F, 3.0F, 2.0F)    // Middle of fin (inverted to point down)
                .texOffs(54, 48)
                .addBox(7.0F, 5.0F, -0.5F, 3.0F, 3.0F, 1.0F),   // Tip of fin (inverted to point down)
            PartPose.offset(0.0F, 8.0F, 0.0F));
            
        // Add larger engine base and components
        partDefinition.addOrReplaceChild("base", 
            CubeListBuilder.create()
                .texOffs(0, 57) // Original base texture
                .addBox(-5.0F, 6.0F, -5.0F, 10.0F, 3.0F, 10.0F), // Original base box
            PartPose.offset(0.0F, 8.0F, 0.0F));

        partDefinition.addOrReplaceChild("nozzle", 
            CubeListBuilder.create()
                // Nozzle Bell (wider, should be at the bottom of the rocket)
                .texOffs(40, 50) // Bell's original texture
                .addBox(-3.0F, 9.0F, -3.0F, 6.0F, 4.0F, 6.0F)  // Y range: 9 to 13 (was 11 to 15 for bell)
                // Nozzle Throat (narrower, should connect bell to rocket base)
                .texOffs(40, 48) // Throat's original texture
                .addBox(-2.0F, 13.0F, -2.0F, 4.0F, 2.0F, 4.0F), // Y range: 13 to 15 (was 9 to 11 for throat) // Y range: 11 to 15
            PartPose.offset(0.0F, 8.0F, 0.0F));

        // Add structural support struts
        partDefinition.addOrReplaceChild("strut1", 
            CubeListBuilder.create()
                .texOffs(14, 48)
                .addBox(-4.5F, 0.0F, 0.0F, 1.0F, 10.0F, 1.0F), // Taller left strut
            PartPose.offset(0.0F, 8.0F, 0.0F));

        partDefinition.addOrReplaceChild("strut2", 
            CubeListBuilder.create()
                .texOffs(14, 48)
                .addBox(3.5F, 0.0F, 0.0F, 1.0F, 10.0F, 1.0F), // Taller right strut
            PartPose.offset(0.0F, 8.0F, 0.0F));

        // Add a more prominent payload/equipment section
        partDefinition.addOrReplaceChild("payload", 
            CubeListBuilder.create()
                .texOffs(20, 48)
                .addBox(-3.0F, -12.0F, -3.0F, 6.0F, 6.0F, 6.0F), // Larger cargo/payload section
            PartPose.offset(0.0F, 8.0F, 0.0F));

        // Add larger, more visible windows
        partDefinition.addOrReplaceChild("window1", 
            CubeListBuilder.create()
                .texOffs(30, 54)
                .addBox(-1.0F, -8.0F, -4.2F, 2.0F, 2.0F, 0.4F), // Larger window 1
            PartPose.offset(0.0F, 8.0F, 0.0F));

        partDefinition.addOrReplaceChild("window2", 
            CubeListBuilder.create()
                .texOffs(30, 54)
                .addBox(-1.0F, -8.0F, 3.8F, 2.0F, 2.0F, 0.4F), // Larger window 2
            PartPose.offset(0.0F, 8.0F, 0.0F));

        // Add prominent detail bands for visual interest
        partDefinition.addOrReplaceChild("detail1", 
            CubeListBuilder.create()
                .texOffs(38, 39)
                .addBox(-4.5F, -14.0F, -4.5F, 9.0F, 2.0F, 9.0F), // Upper band detail (wider)
            PartPose.offset(0.0F, 8.0F, 0.0F));

        partDefinition.addOrReplaceChild("detail2", 
            CubeListBuilder.create()
                .texOffs(38, 39)
                .addBox(-4.5F, -2.0F, -4.5F, 9.0F, 2.0F, 9.0F),  // Lower band detail (wider)
            PartPose.offset(0.0F, 8.0F, 0.0F));
            
        // Add texture map with higher resolution
        return LayerDefinition.create(meshDefinition, 64, 64);
    }
    
    static class RocketModel<T extends Entity> extends EntityModel<T> {
        private final ModelPart body;
        private final ModelPart nose;
        private final ModelPart fin1;
        private final ModelPart fin2;
        private final ModelPart fin3;
        private final ModelPart fin4;
        private final ModelPart base;
        private final ModelPart strut1;
        private final ModelPart strut2;
        private final ModelPart nozzle;
        private final ModelPart payload;
        private final ModelPart window1;
        private final ModelPart window2;
        // Additional detail parts - these can be null if not defined in the model
        private final ModelPart detailPart1;
        private final ModelPart detailPart2;
        
        // The type of rocket this model represents
        private final String rocketType;
        
        public RocketModel(ModelPart root, String type) {
            this.rocketType = type;
            
            // Required parts
            this.body = root.getChild("body");
            this.nose = root.getChild("nose");
            this.fin1 = root.getChild("fin1");
            this.fin2 = root.getChild("fin2");
            this.fin3 = root.getChild("fin3");
            this.fin4 = root.getChild("fin4");
            
            // Required parts that were previously missing in model definition
            this.base = root.getChild("base");
            this.strut1 = root.getChild("strut1");
            this.strut2 = root.getChild("strut2");
            this.nozzle = root.getChild("nozzle");
            this.payload = root.getChild("payload");
            this.window1 = root.getChild("window1"); 
            this.window2 = root.getChild("window2");
            
            // Additional details that may be present
            this.detailPart1 = root.hasChild("detailPart1") ? root.getChild("detailPart1") : null;
            this.detailPart2 = root.hasChild("detailPart2") ? root.getChild("detailPart2") : null;
            
            // Customize model based on rocket type to match reference image
            if (type.equals("probe")) {
                // PROBE/SATELLITE - leftmost in reference image
                // Small, compact satellite with tech details
                
                // Main cylindrical body - ensure all parts visually overlap
                this.body.visible = true;
                this.body.xScale = 0.6F; // Smaller for probe
                this.body.yScale = 2.0F; // Significantly extended to ensure overlap with nose and nozzle
                this.body.zScale = 0.6F; // Smaller for probe
                this.body.y = 0F; // Origin for our coordinate system
                
                // Technical components as nose - ensure significant overlap with body
                this.nose.visible = true;
                this.nose.y = -3F; // Positioned to overlap with the body instead of just touching
                this.nose.xScale = 0.5F; // Smaller for probe
                this.nose.yScale = 1.2F; // Extended to ensure significant overlap with body
                this.nose.zScale = 0.5F; // Smaller for probe
                
                // Satellite legs/fins - small and properly aligned
                this.fin1.visible = true;
                this.fin2.visible = true;
                this.fin3.visible = true;
                this.fin4.visible = true;
                
                // Fin 1 (front) - smaller for probe, properly aligned
                this.fin1.xScale = 0.6F;
                this.fin1.yScale = 0.8F;
                this.fin1.zScale = 0.6F;
                this.fin1.xRot = 0.0F; // No rotation - keep fins straight
                this.fin1.yRot = 0.0F; // No rotation
                this.fin1.zRot = 0.0F; // No rotation
                this.fin1.y = 4F; // Lower position for support legs
                
                // Fin 2 (back) - smaller for probe, properly aligned
                this.fin2.xScale = 0.6F;
                this.fin2.yScale = 0.8F;
                this.fin2.zScale = 0.6F;
                this.fin2.xRot = 0.0F; // No rotation - keep fins straight
                this.fin2.yRot = 0.0F; // No rotation
                this.fin2.zRot = 0.0F; // No rotation
                this.fin2.y = 4F; // Lower position for support legs
                
                // Fin 3 (left) - smaller for probe, properly aligned
                this.fin3.xScale = 0.6F;
                this.fin3.yScale = 0.8F;
                this.fin3.zScale = 0.6F;
                this.fin3.xRot = 0.0F; // No rotation - keep fins straight
                this.fin3.yRot = 0.0F; // No rotation
                this.fin3.zRot = 0.0F; // No rotation
                this.fin3.y = 4F; // Lower position for support legs
                
                // Fin 4 (right) - smaller for probe, properly aligned
                this.fin4.xScale = 0.6F;
                this.fin4.yScale = 0.8F;
                this.fin4.zScale = 0.6F;
                this.fin4.xRot = 0.0F; // No rotation - keep fins straight
                this.fin4.yRot = 0.0F; // No rotation
                this.fin4.zRot = 0.0F; // No rotation
                this.fin4.y = 4F; // Lower position for support legs
                
                // Small engine nozzle - ensure overlap with body
                this.nozzle.visible = true;
                this.nozzle.xScale = 0.8F;
                this.nozzle.yScale = 1.5F; // Extended to ensure significant overlap with body
                this.nozzle.zScale = 0.8F;
                this.nozzle.y = 3.0F; // Positioned to overlap with the body instead of just touching
                
                // No windows for probe
                this.window1.visible = false;
                this.window2.visible = false;
                
                // Use details as tech components/antennas
                if (this.detailPart1 != null) {
                    this.detailPart1.visible = true;
                    this.detailPart1.y = -5F; // Position antenna to overlap with nose for continuity
                    this.detailPart1.xScale = 0.4F;
                    this.detailPart1.yScale = 0.8F;
                    this.detailPart1.zScale = 0.4F;
                }
                if (this.detailPart2 != null) {
                    this.detailPart2.visible = true;
                    this.detailPart2.y = -7F; // Secondary antenna/dish
                    this.detailPart2.xScale = 0.5F;
                    this.detailPart2.yScale = 0.5F;
                    this.detailPart2.zScale = 0.5F;
                }
                
                // Use base as connector between body and engine
                this.base.visible = false; // Hide base to remove black block below rocket // Base is part of the probe design
                this.base.xScale = 0.7F;
                this.base.yScale = 0.5F;
                this.base.zScale = 0.7F;
                this.base.y = 7F; // Position between body and engine
                
                // Use struts as probe arms/sensors
                this.strut1.visible = true;
                this.strut1.xScale = 0.4F;
                this.strut1.yScale = 1.0F;
                this.strut1.zScale = 0.4F;
                this.strut1.x = 1.0F; // Position to the side
                this.strut1.y = -2F; // Position in upper part
                
                this.strut2.visible = true;
                this.strut2.xScale = 0.4F;
                this.strut2.yScale = 1.0F;
                this.strut2.zScale = 0.4F;
                this.strut2.x = -1.0F; // Position to opposite side
                this.strut2.y = -2F; // Position in upper part
                
                // Add tech module/payload section
                this.payload.visible = true;
                this.payload.xScale = 0.8F;
                this.payload.yScale = 0.6F;
                this.payload.zScale = 0.8F;
                this.payload.y = -4F; // Position near top
                
            } else if (type.equals("personal")) {
                // V2 STYLE ROCKET - second from left in reference image
                // Tall, wide enough to hold a player, with windows for visibility
                
                // Body scaled to fit player. Base dimensions from createBodyLayer.
                // Overall render scale for personal rocket: (1.6F, 2.0F, 1.6F)
                this.body.visible = true;
                this.body.xScale = 1.0F; // Base: 8F wide -> Effective: 12.8F
                this.body.yScale = 1.3F; // Base: 22F tall -> Effective: 57.2F
                this.body.zScale = 1.0F; // Base: 8F deep -> Effective: 12.8F
                // this.body.y = 0F; // Rely on createBodyLayer and global render transforms
                
                // Pointed nose cone, proportional to body
                this.nose.visible = true;
                this.nose.xScale = 0.9F;
                this.nose.yScale = 1.2F;
                this.nose.zScale = 0.9F;
                // this.nose.y = -14F; // Rely on createBodyLayer and global render transforms
                
                // Fins - scaled appropriately and aligned straight
                this.fin1.visible = true;
                this.fin1.xScale = 0.8F;
                this.fin1.yScale = 0.9F;
                this.fin1.zScale = 0.8F;
                this.fin1.xRot = 0.0F;
                this.fin1.yRot = 0.0F;
                this.fin1.zRot = 0.0F;

                this.fin2.visible = true;
                this.fin2.xScale = 0.8F;
                this.fin2.yScale = 0.9F;
                this.fin2.zScale = 0.8F;
                this.fin2.xRot = 0.0F;
                this.fin2.yRot = 0.0F;
                this.fin2.zRot = 0.0F;

                this.fin3.visible = true;
                this.fin3.xScale = 0.8F;
                this.fin3.yScale = 0.9F;
                this.fin3.zScale = 0.8F;
                this.fin3.xRot = 0.0F;
                this.fin3.yRot = 0.0F;
                this.fin3.zRot = 0.0F;

                this.fin4.visible = true;
                this.fin4.xScale = 0.8F;
                this.fin4.yScale = 0.9F;
                this.fin4.zScale = 0.8F;
                this.fin4.xRot = 0.0F;
                this.fin4.yRot = 0.0F;
                this.fin4.zRot = 0.0F;
                
                // Engine nozzle
                this.nozzle.visible = true;
                this.nozzle.xScale = 0.9F;
                this.nozzle.yScale = 1.1F;
                this.nozzle.zScale = 0.9F;
                this.nozzle.y = 6.0F; // Explicit Y adjustment from original code
                
                // Windows: enlarged and positioned for player head visibility.
                // In createBodyLayer, window Y is -8.0F, part offset Y is 8.0F. Model Y before this is 0.
                // Negative Y here moves window UP the rocket body (before 180 X-flip).
                this.window1.visible = true;
                this.window1.y = -6.0F; // Initial guess for player head height, adjust after testing
                this.window1.xScale = 1.5F; // Larger window
                this.window1.yScale = 1.5F; // Larger window
                this.window1.zScale = 1.0F;
                
                this.window2.visible = true;
                this.window2.y = -6.0F; // Match window1
                this.window2.xScale = 1.5F; // Larger window
                this.window2.yScale = 1.5F; // Larger window
                this.window2.zScale = 1.0F;
                
                // Hide optional parts for a cleaner V2-style personal rocket
                if (this.detailPart1 != null) this.detailPart1.visible = false;
                if (this.detailPart2 != null) this.detailPart2.visible = false;
                this.strut1.visible = false;
                this.strut2.visible = false;
                this.payload.visible = false;
                this.base.visible = false;
            }
                            else if (type.equals("cargo")) {
                // CARGO ROCKET CONFIGURATION
                this.body.visible = true;
                this.body.xScale = 1.2F; this.body.yScale = 1.5F; this.body.zScale = 1.2F;
                //this.body.y = 0.0F; // Rely on createBodyLayer default Y offset

                this.nose.visible = true;
                this.nose.xScale = 1.1F; this.nose.yScale = 0.9F; this.nose.zScale = 1.1F;
                //this.nose.y = this.body.y + (-16.0F) * (this.body.yScale - this.nose.yScale); // Rely on createBodyLayer default Y offset

                this.base.visible = false; // Hide base to remove black block below rocket
                this.base.xScale = 1.1F; this.base.yScale = 1.1F; this.base.zScale = 1.1F;
                //this.base.y = this.body.y + 6.0F * (this.body.yScale - this.base.yScale); // Rely on createBodyLayer default Y offset

                this.nozzle.visible = true;
                this.nozzle.xScale = 1.3F; this.nozzle.yScale = 1.2F; this.nozzle.zScale = 1.3F;
                this.nozzle.y = 6.0F; // Adjust nozzle position to connect with main body

                this.fin1.visible = true; this.fin2.visible = true; this.fin3.visible = true; this.fin4.visible = true;
                this.fin1.xScale = 1.1F; this.fin1.yScale = 1.0F; this.fin1.zScale = 1.1F; this.fin1.xRot = 0.0F;
                this.fin2.xScale = 1.1F; this.fin2.yScale = 1.0F; this.fin2.zScale = 1.1F; this.fin2.xRot = 0.0F;
                this.fin3.xScale = 1.1F; this.fin3.yScale = 1.0F; this.fin3.zScale = 1.1F; this.fin3.xRot = 0.0F;
                this.fin4.xScale = 1.1F; this.fin4.yScale = 1.0F; this.fin4.zScale = 1.1F; this.fin4.xRot = 0.0F;
                float finAttachPointY_cargo = 2.0F;
                //this.fin1.y = this.body.y + finAttachPointY_cargo * (this.body.yScale - this.fin1.yScale); // Rely on createBodyLayer default Y offset
                //this.fin2.y = this.body.y + finAttachPointY_cargo * (this.body.yScale - this.fin2.yScale); // Rely on createBodyLayer default Y offset
                //this.fin3.y = this.body.y + finAttachPointY_cargo * (this.body.yScale - this.fin3.yScale); // Rely on createBodyLayer default Y offset
                //this.fin4.y = this.body.y + finAttachPointY_cargo * (this.body.yScale - this.fin4.yScale); // Rely on createBodyLayer default Y offset

                this.payload.visible = true;
                this.payload.xScale = 1.0F; this.payload.yScale = 1.0F; this.payload.zScale = 1.0F;
                //this.payload.y = this.body.y + (-10.0F) * (this.body.yScale - this.payload.yScale); // Rely on createBodyLayer default Y offset

                this.window1.visible = true; this.window2.visible = true;
                this.window1.xScale = 1.0F; this.window1.yScale = 1.0F; this.window1.zScale = 1.0F;
                this.window2.xScale = 1.0F; this.window2.yScale = 1.0F; this.window2.zScale = 1.0F;
                //this.window1.y = this.body.y + (-8.0F) * (this.body.yScale - this.window1.yScale); // Rely on createBodyLayer default Y offset
                //this.window2.y = this.body.y + (-8.0F) * (this.body.yScale - this.window2.yScale); // Rely on createBodyLayer default Y offset
                
                if (this.detailPart1 != null) this.detailPart1.visible = false;
                if (this.detailPart2 != null) this.detailPart2.visible = false;
                this.strut1.visible = false;
                this.strut2.visible = false;

            } else { // Default (Research/Mining) Rocket Configuration
                this.body.visible = true;
                this.body.xScale = 1.2F; this.body.yScale = 1.5F; this.body.zScale = 1.2F;
                this.body.y = 0.0F;

                this.nose.visible = true;
                this.nose.xScale = 1.1F; this.nose.yScale = 0.9F; this.nose.zScale = 1.1F;
                this.nose.y = this.body.y + (-16.0F) * (this.body.yScale - this.nose.yScale);

                this.base.visible = false; // Hide base to remove black block below rocket
                this.base.xScale = 1.1F; this.base.yScale = 1.1F; this.base.zScale = 1.1F;
                this.base.y = this.body.y + 6.0F * (this.body.yScale - this.base.yScale);

                this.nozzle.visible = true;
                this.nozzle.xScale = 1.3F; this.nozzle.yScale = 1.2F; this.nozzle.zScale = 1.3F;
                this.nozzle.y = this.base.y + 9.0F * (this.base.yScale - this.nozzle.yScale);

                this.fin1.visible = true; this.fin2.visible = true; this.fin3.visible = true; this.fin4.visible = true;
                this.fin1.xScale = 1.0F; this.fin1.yScale = 1.0F; this.fin1.zScale = 1.0F;
                this.fin2.xScale = 1.0F; this.fin2.yScale = 1.0F; this.fin2.zScale = 1.0F;
                this.fin3.xScale = 1.0F; this.fin3.yScale = 1.0F; this.fin3.zScale = 1.0F;
                this.fin4.xScale = 1.0F; this.fin4.yScale = 1.0F; this.fin4.zScale = 1.0F;
                float finAttachPointY_default = 2.0F;
                this.fin1.y = this.body.y + finAttachPointY_default * (this.body.yScale - this.fin1.yScale);
                this.fin2.y = this.body.y + finAttachPointY_default * (this.body.yScale - this.fin2.yScale);
                this.fin3.y = this.body.y + finAttachPointY_default * (this.body.yScale - this.fin3.yScale);
                this.fin4.y = this.body.y + finAttachPointY_default * (this.body.yScale - this.fin4.yScale);

                this.payload.visible = true; 
                this.payload.xScale = 1.0F; this.payload.yScale = 1.0F; this.payload.zScale = 1.0F;
                this.payload.y = this.body.y + (-10.0F) * (this.body.yScale - this.payload.yScale);

                this.window1.visible = true; this.window2.visible = true; 
                this.window1.xScale = 1.0F; this.window1.yScale = 1.0F; this.window1.zScale = 1.0F;
                this.window2.xScale = 1.0F; this.window2.yScale = 1.0F; this.window2.zScale = 1.0F;
                this.window1.y = this.body.y + (-8.0F) * (this.body.yScale - this.window1.yScale);
                this.window2.y = this.body.y + (-8.0F) * (this.body.yScale - this.window2.yScale);
                
                if (this.detailPart1 != null) this.detailPart1.visible = false;
                if (this.detailPart2 != null) this.detailPart2.visible = false;
                this.strut1.visible = false;
                this.strut2.visible = false;
            }
        }
        
        // New methods for rendering specific parts of the rocket
        
        // Render the main body parts of the rocket
        public void renderBody(PoseStack poseStack, VertexConsumer buffer, int packedLight, 
                              int packedOverlay, float red, float green, float blue, float alpha) {
            body.render(poseStack, buffer, packedLight, packedOverlay, red, green, blue, alpha);
            payload.render(poseStack, buffer, packedLight, packedOverlay, red, green, blue, alpha);
            base.render(poseStack, buffer, packedLight, packedOverlay, red, green, blue, alpha);
            
            if (window1.visible) {
                window1.render(poseStack, buffer, packedLight, packedOverlay, red, green, blue, alpha);
            }
            
            if (window2.visible) {
                window2.render(poseStack, buffer, packedLight, packedOverlay, red, green, blue, alpha);
            }
            
            if (detailPart1 != null && detailPart1.visible) {
                detailPart1.render(poseStack, buffer, packedLight, packedOverlay, red, green, blue, alpha);
            }
            
            if (detailPart2 != null && detailPart2.visible) {
                detailPart2.render(poseStack, buffer, packedLight, packedOverlay, red, green, blue, alpha);
            }
        }
            // Render just the nose cone
        public void renderNose(PoseStack poseStack, VertexConsumer buffer, int packedLight, 
                              int packedOverlay, float red, float green, float blue, float alpha) {
            nose.render(poseStack, buffer, packedLight, packedOverlay, red, green, blue, alpha);
        }
        
        // Render the fins
        public void renderFins(PoseStack poseStack, VertexConsumer buffer, int packedLight, 
                              int packedOverlay, float red, float green, float blue, float alpha) {
            fin1.render(poseStack, buffer, packedLight, packedOverlay, red, green, blue, alpha);
            fin2.render(poseStack, buffer, packedLight, packedOverlay, red, green, blue, alpha);
            fin3.render(poseStack, buffer, packedLight, packedOverlay, red, green, blue, alpha);
            fin4.render(poseStack, buffer, packedLight, packedOverlay, red, green, blue, alpha);
        }
        
        // Render the engine nozzle
        public void renderNozzle(PoseStack poseStack, VertexConsumer buffer, int packedLight, 
                                int packedOverlay, float red, float green, float blue, float alpha) {
            nozzle.render(poseStack, buffer, packedLight, packedOverlay, red, green, blue, alpha);
        }
        
        @Override
        public void setupAnim(@javax.annotation.Nonnull T entity, float limbSwing, float limbSwingAmount, float ageInTicks, 
                             float netHeadYaw, float headPitch) {
            // Animation is based directly on ageInTicks
            
            // Check entity type and state - add different animations based on rocket state
            if (entity instanceof com.astrolabs.astroexpansion.common.entity.PersonalRocketEntity ||
                entity instanceof com.astrolabs.astroexpansion.common.entity.ProbeRocketEntity) {
                // More pronounced pre-launch vibration
                float preLaunchVibration = (float)Math.sin(ageInTicks * 1.2F) * 0.02F;
                body.zRot = preLaunchVibration;
                nose.zRot = preLaunchVibration;
                payload.zRot = preLaunchVibration;
                
                // Occasional sharper vibration pulses
                if ((int)ageInTicks % 20 < 5) {
                    float pulse = (float)Math.sin(ageInTicks * 3.0F) * 0.03F;
                    body.zRot += pulse;
                    nozzle.xScale = 1.0F + pulse * 0.5F;
                    nozzle.zScale = 1.0F + pulse * 0.5F;
                }
                
                fin1.zRot = preLaunchVibration * 1.5F;
                fin2.zRot = preLaunchVibration * 1.5F;
                fin3.zRot = preLaunchVibration * 1.5F;
                fin4.zRot = preLaunchVibration * 1.5F;
            } 
            else {
                // Very subtle idle wobble animation for stationary rockets
                float idleWobble = (float)Math.sin(ageInTicks * 0.4F) * 0.01F;
                
                // Apply subtle movement to simulate idle vibration
                body.zRot = idleWobble;
                nose.zRot = idleWobble;
                payload.zRot = idleWobble;
                
                // Fins might wobble slightly more due to wind
                fin1.zRot = idleWobble * 1.2F;
                fin2.zRot = idleWobble * 1.2F;
                fin3.zRot = idleWobble * 1.2F;
                fin4.zRot = idleWobble * 1.2F;
                
                // Add subtle movement to detail parts based on rocket type
                if (detailPart1 != null && detailPart1.visible) {
                    // Different movement patterns based on rocket type
                    if (rocketType.equals("personal")) {
                        detailPart1.yRot = idleWobble * 0.8F;
                    } else if (rocketType.equals("cargo")) {
                        detailPart1.xRot = idleWobble * 1.0F;
                    }
                }
                
                if (detailPart2 != null && detailPart2.visible) {
                    // Different movement patterns based on rocket type
                    if (rocketType.equals("personal")) {
                        detailPart2.yRot = idleWobble * 0.8F;
                    } else if (rocketType.equals("cargo")) {
                        detailPart2.zRot = idleWobble * 1.0F;
                    }
                }
            }
            
            // Base and struts always remain steady as they're connected to the launch rail
            base.zRot = 0;
            strut1.zRot = 0;
            strut2.zRot = 0;
        }
        
        @Override
        public void renderToBuffer(@javax.annotation.Nonnull PoseStack poseStack, @javax.annotation.Nonnull VertexConsumer buffer, int packedLight, 
                                  int packedOverlay, float red, float green, float blue, float alpha) {
            // Render all rocket parts
            // Structure components (base first to appear firmly attached)
            base.render(poseStack, buffer, packedLight, packedOverlay, red, green, blue, alpha);
            strut1.render(poseStack, buffer, packedLight, packedOverlay, red, green, blue, alpha);
            strut2.render(poseStack, buffer, packedLight, packedOverlay, red, green, blue, alpha);
            nozzle.render(poseStack, buffer, packedLight, packedOverlay, red, green, blue, alpha);
            
            // Main rocket body and components
            body.render(poseStack, buffer, packedLight, packedOverlay, red, green, blue, alpha);
            payload.render(poseStack, buffer, packedLight, packedOverlay, red, green, blue, alpha);
            nose.render(poseStack, buffer, packedLight, packedOverlay, red, green, blue, alpha);
            
            // Fins
            fin1.render(poseStack, buffer, packedLight, packedOverlay, red, green, blue, alpha);
            fin2.render(poseStack, buffer, packedLight, packedOverlay, red, green, blue, alpha);
            fin3.render(poseStack, buffer, packedLight, packedOverlay, red, green, blue, alpha);
            fin4.render(poseStack, buffer, packedLight, packedOverlay, red, green, blue, alpha);
            
            // Details
            window1.render(poseStack, buffer, packedLight, packedOverlay, red, green, blue, alpha);
            window2.render(poseStack, buffer, packedLight, packedOverlay, red, green, blue, alpha);
        }
    }
}